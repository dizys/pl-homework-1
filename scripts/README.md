# Programming Languages Homework 1

> This directory and its content are auto-generated by script `repo/package.sh`
> to conform to the file naming scheme required by this assignment. The complete
> repository could be found under the folder `repo` where more details are
> available.

An EBNF-to-BNF Bison rule translator built using Flex and Bison. Actions
are completely ignored during translation.

Supported extended expressions:
- `<A>` or `A*`: zero or more occurrences of A
- `A+`: one or more occurrences of A
- `[A]`: zero or one occurrences of A
- `(A||B)`: grouping, in which an `or` operator should appear as `||` instead 
of a single `|`

## 1. Project structure

```
project
├─repo                          
├─dist                          Build artifacts (created after build)
│  ├─bin                            Folder to hold generated binaries
│  │  ├─tinybasic                       Executable binary of TinyBasic parser 
│  │  └─trans                           Executable binary of translator
│  │
│  └─c_src                          Folder to hold generated C codes
│   
├─<NET_ID>.tinybasic.in           TinyBasic parser source in Extended-Bison
├─<NET_ID>.tinybasic.l            TinyBasic tokenizer source in Flex
├─<NET_ID>.tinybasic.sh           Shell script for building TinyBasic parser
├─<NET_ID>.tinybasic.y            Would be generated by translator from 'tinybasic.in'
├─<NET_ID>.trans.l                Translator tokenizer source in Flex
├─<NET_ID>.trans.sh               Shell script for building translator
├─<NET_ID>.trans.y                Translator parser source in Bison
├─<NET_ID>.treenode.cpp           AST tree node source in C++
├─<NET_ID>.treenode.h             treenode header file
│
...
```

## 2. Build the translator

To build the translator, simply run the following shell script via CLI:

```sh
./<NET_ID>.trans.sh
```

Then, the executable binary should be available at `<NET_ID>_dist/bin/trans`

## 3. Test the translator by the example of TinyBasic

To test the translator, you can build a TinyBasic parser using the following
script:

```sh
./<NET_ID>.tinybasic.sh
```

In this script, it will first use the translator that we built in the last step 
to translate the Extended-Bison file (`<NET_ID>.tinybasic.in`) from EBNF rules 
to BNF ones, thus producing a standard Bison file `<NET_ID>.tinybasic.y`.

Then it will use Bison and Flex separately to process file `<NET_ID>.tinybasic.y`
and `<NET_ID>.tinybasic.l`. The generated C source files will all be available 
under the path `<NET_ID>_dist/c_src/`.

Finally, it will run `g++` to compile the generated C source files and output an
executable binary file for the TinyBasic parser at the path 
`<NET_ID>_dist/bin/tinybasic`.

## 4. Limitations for the translator

### 4.1 Actions are ignored

Because new productions could be generated during translation, and it's
difficult to match original actions to new productions, actions are
completely ignored during translation, and the translation result would
contain no action code blocks.

### 4.2 Nested blocks in actions are not supported

Because it's impossible to represent the recursive structure of nested
blocks using a single standard regular expression, action block with only
one level of matching curly brackets can be matched by the regular
expression. A possible solution would be further defining C/C++ tokens and
grammar structure in Flex and Bison. But that would be out of topic for
this project.

For example, the following file would throw an error when being translated.

```bison
%%

digit:
    '2' {
      if (flag) {
        flag = 0;
        $$ = new node($1);
      } // if block cannot be matched
    }
  |
    '3'
  ;

%%
```

### 4.3 Generated rules are not optimal

The generated rules are correct BNF rules, but sometimes can be too verbose
and even with meaningless nodes.

For example, a possible translation result could be as follow:

```
%%
digit:
    digit_expr
  ;

digit_expr:
    'a'
  |
    'b'
  ;
%%
```

In this example, non-terminal `digit_expr` is completely unnecessary as
`digit_expr` here is just an alias for `digit`.

This is due to how the Bison rules are defined in this project to support
EBNF . Because `digit_expr` could also be used inside, for example, a
repetition rule like `number -> digit_expr+` where `digit_expr` is a
necessary non-terminal for it to be translated into BNF rule
`number -> digit_expr | digit_expr number`.

Optimizations can be done to eliminate redundancies like this. For example,
by visiting the AST, find out rules like `A -> B` where `B` is only used
here. Then just delete this rule and rename `B` as `A`. Unfortunately due
to time limit, this has not been implemented yet.
