%{
#include <iostream>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <cstddef>
#include "treenode.h"

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };

using namespace asttree;
%}

%union {
   treenode* val;
};

%start prog
%token <val> TERM_OR_NONTERM REWRITES SEMI REP_ZERO_LEFT REP_ZERO_RIGHT ENDL SECTION
%token <val> OPTION_LEFT OPTION_RIGHT
%token <val> GROUPING_LEFT GROUPING_RIGHT GROUP_OR
%token <val> RULE_OR
%token <val> REP_ONE REP_ZERO

%type <val> prog statements statement epsilon_trans_expr expr subexpr quant base term_and_nonterms

%%

prog: SECTION statements SECTION {
    std::cout<<"haha"<<std::endl;
}
    ;

statements:  statement             {  }
    |   statement statements        {  }
    ;

statement:  TERM_OR_NONTERM REWRITES epsilon_trans_expr SEMI { cout << "statement finished" << endl;  }
    ;

epsilon_trans_expr:  ENDL RULE_OR expr { }
    |   expr   { }
    ;

 /* Fill in any other rules here */

expr: subexpr   {  }
    | subexpr RULE_OR expr  { }
    ;

subexpr: quant { }
    | quant GROUP_OR subexpr { }
    ;

quant: base  { }
    | base REP_ONE { }
    | base REP_ZERO { }
    | REP_ZERO_LEFT base REP_ZERO_RIGHT { }
    | OPTION_LEFT base OPTION_RIGHT { }
    ;

base: GROUPING_LEFT subexpr GROUPING_RIGHT { }
    | term_and_nonterms { }
    ;

term_and_nonterms: TERM_OR_NONTERM { }
    | TERM_OR_NONTERM term_and_nonterms { }
    ;

%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}
