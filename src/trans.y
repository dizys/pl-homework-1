%{
#include <iostream>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <cstddef>
#include "treenode.h"

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };

using namespace asttree;
%}

%union {
    treenode* val;
};

%start prog
%token <val> TERM_OR_NONTERM REWRITES SEMI REP_ZERO_LEFT REP_ZERO_RIGHT ENDL SECTION
%token <val> OPTION_LEFT OPTION_RIGHT
%token <val> GROUPING_LEFT GROUPING_RIGHT GROUP_OR
%token <val> RULE_OR
%token <val> REP_ONE REP_ZERO

%type <val> prog statements statement epsilon_trans_expr expr subexpr quant base term_and_nonterms

%%

prog:
        SECTION statements SECTION {
            $$ = new prog($1,$2,$3);
        }
    ;

statements:
        statement {
            $$ = new statements($1);
        }
    |
        statement statements {
            $$ = new statements($1, $2);
        }
    ;

statement:
        TERM_OR_NONTERM REWRITES epsilon_trans_expr SEMI {
            $$ = new statement($1, $2, $3, $4);
        }
    ;

epsilon_trans_expr:
        ENDL RULE_OR expr {
            $$ = new epsilon_trans_expr($1, $2, $3);
        }
    |
        expr {
            $$ = new epsilon_trans_expr($1);
        }
    ;

 /* Fill in any other rules here */

expr:
        subexpr {
            $$ = new expr($1);
        }
    |
        subexpr RULE_OR expr {
            $$ = new expr($1, $2, $3);
        }
    ;

subexpr:
        quant {
            $$ = new subexpr($1);
        }
    |
        quant GROUP_OR subexpr {
            $$ = new subexpr($1, $2, $3);
        }
    ;

quant:
        base {
            $$ =  new quant($1);
        }
    |
        base REP_ONE {
            $$ = new quant($1, $2);
        }
    |
        base REP_ZERO {
            $$ = new quant($1, $2);
        }
    |
        REP_ZERO_LEFT base REP_ZERO_RIGHT {
            $$ = new quant($1, $2, $3);
        }
    |
        OPTION_LEFT base OPTION_RIGHT {
            $$ = new quant($1, $2, $3);
        }
    ;

base:
        GROUPING_LEFT subexpr GROUPING_RIGHT {
            $$ = new base($1, $2, $2);
        }
    |
        term_and_nonterms {
            $$ = new base($1);
        }
    ;

term_and_nonterms:
        TERM_OR_NONTERM {
            $$ = new term_and_nonterms($1);
        }
    |
        TERM_OR_NONTERM term_and_nonterms {
            $$ = new term_and_nonterms($1, $2);
        }
    ;

%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}
