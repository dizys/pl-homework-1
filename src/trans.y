%{
/* Translator Parser Source in Bison
 * 
 * by Ziyang Zeng (zz2960)
 * Feb. 2021
 */
#include <iostream>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <cstddef>
#include "treenode.h"

extern int yylineno;

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { 
  std::cerr << "Error: " << p << " on line " << yylineno << std::endl; 
  return 1;
};

using namespace asttree;
using namespace std;
%}

%union {
  treenode* val;
};

%start prog
%token <val> TERM_OR_NONTERM REWRITES SEMI REP_ZERO_LEFT REP_ZERO_RIGHT ENDL SECTION
%token <val> OPTION_LEFT OPTION_RIGHT
%token <val> GROUPING_LEFT GROUPING_RIGHT GROUP_OR
%token <val> RULE_OR
%token <val> REP_ONE REP_ZERO

%left TERM_OR_NONTERM

%type <val> prog statements statement epsilon_trans_expr expr subexpr concat quant base term_and_nonterms

%%

prog:
    SECTION statements SECTION {
      $$ = new prog($1,$2,$3);
      $$->doConversion();
      $$->print(cout);
    }
  ;

statements:
    statement {
      $$ = new statements($1);
    }
  |
    statement statements {
      $$ = new statements($1, $2);
    }
  ;

statement:
    TERM_OR_NONTERM REWRITES epsilon_trans_expr SEMI {
        $$ = new statement($1, $2, $3, $4);
    }
  ;

epsilon_trans_expr:
    ENDL RULE_OR expr {
      $$ = new epsilon_trans_expr($1, $2, $3);
    }
  |
    ENDL expr {
      $$ = new epsilon_trans_expr($2);
    }
  |
    expr {
      $$ = new epsilon_trans_expr($1);
    }
  ;

 /* Fill in any other rules here */

expr:
    subexpr {
      $$ = new expr($1);
    }
  |
    subexpr RULE_OR expr {
      $$ = new expr($1, $2, $3);
    }
  ;

subexpr:
    concat {
      $$ = new subexpr($1);
    }
  |
    concat GROUP_OR subexpr {
      $$ = new subexpr($1, $2, $3);
    }
  ;

concat:
    quant {
      $$ = new concat($1);
    }
  |
    quant concat {
      $$ = new concat($1, $2);
    }
  ;

quant:
  base {
      $$ =  new quant($1);
    }
  |
    base REP_ONE {
      $$ = new quant($1, $2);
    }
  |
    base REP_ZERO {
      $$ = new quant($1, $2);
    }
  |
    REP_ZERO_LEFT subexpr REP_ZERO_RIGHT {
      $$ = new quant($1, $2, $3);
    }
  |
    OPTION_LEFT subexpr OPTION_RIGHT {
      $$ = new quant($1, $2, $3);
    }
  ;

base:
    GROUPING_LEFT subexpr GROUPING_RIGHT {
      $$ = new base($1, $2, $2);
    }
  |
    term_and_nonterms {
      $$ = new base($1);
    }
  ;

term_and_nonterms:
    TERM_OR_NONTERM {
      $$ = new term_and_nonterms($1);
    }
  |
    TERM_OR_NONTERM term_and_nonterms {
      $$ = new term_and_nonterms($1, $2);
    }
  ;

%%

int main()
{
  yyparse(); // A parsing function that will be generated by Bison.
  return 0;
}
