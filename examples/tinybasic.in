%{
/* Tiny Basic EBNF example */
#include <iostream>

extern int yylineno;

int yylex();
int yyerror(const char *p) { 
  std::cerr << "Error: " << p << " on line " << yylineno << std::endl; 
  return 1;
};
%}

%start program
%token CR DIGIT LPAREN RPAREN VAR MULDIV PLUMIN
%token COMMA STRING
%token RETURN CLEAR LIST RUN END
%token PRINT RELOP IF THEN GOTO INPUT LET GOSUB

%type program line statement expr_list var_list expression
%type term factor number

%%

program: (line)+;

line: number statement CR | statement CR | CR;

statement: PRINT expr_list
  |  IF expression RELOP expression THEN statement
  |  GOTO expression
  |  INPUT var_list
  |  LET VAR '=' expression
  |  GOSUB expression
  |  RETURN
  |  CLEAR
  |  LIST
  |  RUN
  |  END
  ;

expr_list: (STRING||expression) (COMMA (STRING||expression) )*;
var_list: VAR (COMMA VAR)*;
expression: [PLUMIN] term (PLUMIN term)*;
term: factor (MULDIV factor)*;
factor: VAR | number | LPAREN expression RPAREN;
number: DIGIT+;

%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}
